\chapter{Układy programowalne}
Kiedy w 1985 roku, dzięki szybko rozwijającej się litografii, wprowadzono pierwszy komercyjnie dostępny układ typu FPGA~(ang. \textit{Field Programmable Gate Array}) - układ XC2064 - bardzo szybko doceniono jego zalety wszędzie tam, gdzie wymagana jest łatwa zmiana funkcjonalności systemu przetwarzania danych. Głównym motorem rozwoju, szczególnie na początku, było powstanie i gwałtowna ekspansja Internetu i konieczność łatwego prototypowania oraz wdrażania nowych rozwiązań zwłaszcza jeśli chodzi o tworzenie przełączników i ruterów~\cite{Designing_with_Xilinx}.

Tak duże zainteresowanie tymi układami bierze się z faktu, iż są one w łatwy sposób rekonfigurowalne a przez to mogą realizować dowolne funkcje logiczne. W przeciwieństwie do ogólnodostępnych układów typu CPU~(ang. \textit{Central Processing Unit}), których działanie opiera się na sekwencyjnym przetwarzaniu listy rozkazów w obrębie przewidzianej przez producenta \textit{architektury instrukcji}~(ang.~\textit{Instruction Set Architecture, ISA})~\cite{INTEL_ISA} układy FPGA są konfigurowalne na poziomie sprzętowym a nie programowane. Zakupiony od producenta procesor po podaniu mu danych oraz listy instrukcji~(programu) będzie je przetwarzał i na wyjściu otrzyma się oczekiwaną wartość. Układ FPGA nie zrealizuje żadnej operacji mimo podania konkretnych danych wejściowych, jeśli nie zostanie skonfigurowany\footnote{Rozróżnienie pomiędzy konfiguracją a programowaniem powinno wybrzmieć dostatecznie mocno. Na dalszych kartach tej pracy terminy te będą używane zamiennie w kontekście układów FPGA, co jest podyktowane technologią użytą do wykonania projektu magisterskiego.}.

Na konfigurowalność układów FPGA składają się wspólnie dwa czynniki - obecność \textit{bloków logicznych}~(ang.~\textit{logic blocks}) oraz elastycznej~(tzn. konfigurowalnej) sieci połączeń między nimi~(ang. \textit{routing}) zdolnej teoretycznie wytworzyć połączenie pomiędzy dowolnymi blokami.
\addimage{chapters/ch2/img/fpgaBigPicture.png}{scale=0.4}{Schemat ideowy budowy układu FPGA. Bloki logiczne (LB) połączone są między sobą oraz z blokami wejścia-wyjścia~(IOB) za pomocą gęstej sieci konfigurowalnych połączeń. Bloki wejścia-wyjścia służą do ustanowienia komunikacji z urządzeniami peryferyjnymi takimi jak moduł pamięci RAM czy klawiatura}{Schemat ideowy budowy układu FPGA}{ch2:img:fpgaBigPicture}
Każdy blok logiczny składa się minimalnie z trzech elementów:
\begin{itemize}
\item n-wejściowej konfigurowalnej \textit{tablicy przeglądowej}~(ang. \textit{LookUp Table}), której zadaniem jest realizacja n-parametrowej funkcji logicznej np. $(\bar{A}\vee B) \wedge C$ jest 3-parametrową funkcją logiczną,
\item \textit{przerzutnika}~(ang. \textit{flip-flop}) działającego jako pamięć,
\item \textit{multipleksera}~(ang. \textit{multiplexer}), który dokonuje wyboru źródła sygnału, który ma zostać przekazany na wyjście bloku logicznego.
\end{itemize}
\addimage{chapters/ch2/img/fpgaLB}{scale=0.35}{Budowa podstawowego bloku logicznego w układzie FGPA. 4-wejściowy LUT realizuje ustaloną funkcję logiczną, której wynik, zależny od kombinacji sygnałów (I[0]:I[3]), przekazywany jest do przerzutnika (FF) w celu zapamiętania. Przerzutnik działa synchronicznie z doprowadzonym sygnałem zegarowym~(CLK) a jego zawartość może być zresetowana~(RST). O tym, jaka wartość~(O) zostanie podana na wyjściu bloku logicznego decyduje parametr~(S) sterujący wyborem multipleksera~(MX) pomiędzy nowym a zapamiętanym uprzednio wynikiem działania.}{Budowa podstawowego bloku logicznego w układzie FGPA}{ch2:img:fpgaLB}
Pojedynczy blok logiczny sam w sobie jest dość prymitywnym elementem i samodzielnie nie jest w stanie realizować funkcji, której liczba parametrów wejściowych przekracza ilość wejść do LUT. Jednak dzięki występującej sieci połączeń\footnote{W literaturze często wspomina się o blokach logicznych zanurzonych w morzu połączeń.} wyjście jednego bloku logicznego może stanowić wejście drugiego. W ten sposób tworzone są znacznie bardziej rozbudowane funkcje logiczne. Wynika też z tego, że im więcej i im bardziej rozbudowane są bloki logiczne tym możliwości w zakresie komponowania funkcjonalności są szersze~(wtedy jednak pojawiają się dodatkowe wyzwania konstruktorskie związane z optymalnym projektem sieci połączeń{\color{red}ARCHITEKTURY BUDOWY SIECI REF}).
\addimage{chapters/ch2/img/fpgaSizeCost.png}{scale=0.4}{Rozwój układów FPGA od momentu ich konstrukcji do dziś. Wartości podane na wykresie są liczone względem pierwotnego układu XC2064, który posiadał 64 programowalne bloki logiczne. Kwadratami oznaczono względną pojemność układu rozumianą poprzez ilość elementów logicznych, zamalowane koła osiągalne częstotliwości, ciągła gruba linia to cena, a linia z krzyżykami to pobierana moc. Widoczny jest znaczny postęp, który dokonał się na przestrzeni ostatnich lat~\cite{Designing_with_Xilinx}}{Rozwój układów FPGA od momentu ich konstrukcji do dziś}{ch2:img:fpgaSizeCost}

Lata rozwoju układów FPGA połączone z analizą często wykorzystywanych algorytmów doprowadziły do implementacji dodatkowych elementów wchodzących w skład bloków logicznych. Są to jednostki bardziej wyspecjalizowane niż LUT, których użycie sprawia, że dany typ zadania może być wykonany znacznie szybciej i/lub jest bardziej ekonomiczne pod względem wykorzystania powierzchni układu. Tak powstały m. in:
\begin{itemize}
\item pamięci o niewielkiej pojemności LUTRAM,
\item pamięci blokowe~(ang. \textit{block RAM, BRAM}), zdolne do przechowywania porcji danych rzędu 18~kb i wykonania do dwóch operacji dostępu w jednym cyklu zegara,
\item moduły DSP dedykowane szybkiemu przetwarzaniu operacji dodawania i mnożenia.
\end{itemize}
Znajomość liczby, typu elementów składających się na układ FPGA oraz wymagań stawianych na etapie projektowania algorytmów pozwala dobrać odpowiedni układ do danych zastosowań, a przez to zoptymalizować koszty, które generowane byłyby przez elementy niewykorzystane. Producenci, chcąc sprostać oczekiwaniom rynkowym dostarczają całe gamy produktów, których wielkość mierzona za pomocą ilości bloków logicznych może zaczynać się na ok. 1000 bloków a kończyć na paru milionach~\cite{XILINX_PRODUCT_TABLE}.

Elastyczność w zakresie budowania funkcji logicznych posiada jednakże pewną niedogodność związaną z maksymalnymi osiągalnymi częstotliwościami pracy układów. W części przypadków~(w tym omawianego systemu śledzenia promieni) samo przetworzenie sygnałów w bloku logicznym może trwać zaledwie 20-30\% budżetu czasowego wynikającego z okresu zadanego zegara. Pozostały czas jest czasem potrzebnym na propagację wyniku do kolejnego bloku logicznego. W efekcie uzyskiwane maksymalne częstotliwości zegara dla specyficznych zastosowań przetwarzania sygnałów~(ang. \textit{Digital Signal Processing, DSP}) mogą przekraczać 500~MHz\footnote{Tak wysokie częstotliwości, jak na układy FPGA są możliwe do uzyskania tylko dzięki obecności dedykowanych bloków DSP w strukturze układu FPGA.}, a w typowych zastosowaniach są to wartości pomiędzy 200 a 400 MHz~(wartości te zależą oczywiście od technologii wykonania układu FPGA, akcelerowanego algorytmu i jakości kodu). W porównaniu do obecnych dzisiaj procesorów CPU działających coraz częściej z częstotliwościami sięgającymi 4 GHz są to wartości 10- 20-krotnie niższe. Wydawać mogłoby się zatem~(tylko na podstawie porównania osiąganych częstotliwości), że nie można oczekiwać zbliżonej i wyższej wydajności od układu FPGA realizującego identyczny algorytm co odpowiadający mu procesor CPU. Nie musi być to prawdą. Zależnie od typu rozwiązywanego problemu jak i umiejętności projektanta, algorytmy mogą być wykonywane o całe rzędy wielkości szybciej niż ich odpowiedniki opisane listą rozkazów CPU przy niższym zegarze oraz niższej konsumpcji energii elektrycznej. Kluczowa jest tu świadomość, iż projektant ma bezpośredni wpływ na to, jak układ zostanie skonfigurowany. Ta dowolność nierozerwalnie wiąże się z dużą odpowiedzialnością oraz stopniem wymaganego doświadczenia.

\section{Konfiguracja i języki opisu sprzętu}
\section{Nowoczesne podejście}

\section{Xilinx i ich rodziny układów FPGA}
\subsection{Dobór układu w projekcie}

\section{Budowa oraz znaczenie poszczególnych elementów}

\section{Projektowanie funkcjonalności}
\subsection{Tradycyjne podejście}
\subsection{Synteza wysokiego poziomu}
co robi, co można a co nie, dyrektywy preprocesora,

\section{Sytnteza układu oraz implementacja w FPGA}
\subsection{PLUNIFY - INTIME}
???
\subsection{Vivado IP Integrator \& Processor Options}

