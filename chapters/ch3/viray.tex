\chapter{Akcelerator śledzenia promieni z użyciem układu FPGA}
\section{Założenia}
Wszystko, o czym wspomniano do tej pory w poprzedzających rozdziałach miało na celu stworzyć podwaliny teoretyczne, które mogą zostać wykorzystane w praktyce do budowy systemu śledzenia promieni w oparciu o układy FPGA. Projekt, którego realizacji się podjęto zakładał od samego początku:
\begin{enumerate}
\item Przy użyciu Vivado HLS
\item zaprojektowanie modułu do akceleracji grafiki metodą śledzenia promieni,
\item zdolnego do wizualizacji świata złożonego z prostych kształtów geometrycznych,
\item których powierzchnie zachowują się zgodnie z odpowiednimi funkcjami BSDF,
\item w czasie rzeczywistym.
\end{enumerate}

Chociaż sposób wykonania projektu był zmieniany w czasie, powyższe wymagania pozostawały aktualne. Warto jednak w tym momencie dokonać sprecyzowania każdego z nich.

\begin{enumerate}
\item Głównym, nadrzędnym celem pracy była ewaluacja możliwości Vivado HLS, jako narzędzia umożliwiającego porzucenie konfiguracji za pomocą HDL na rzecz opisu algorytmicznego w języku podobnym do C/C++. W momencie rozpoczęcia projektu znane były wyniki i wnioski z prac eksperymentalnych używających tego narzędzia w pewnych typowych zastosowaniach. Szczególnie ważna okazała się być informacja, o tym, że Vivado HLS posiada tendencję do tworzenia opisu RTL powodującego użycie stosunkowo dużej ilości elementów logicznych znajdujących się w układzie. Chcąc mieć swobodę w tworzeniu funkcjonalności należało dysponować układem FPGA o odpowiednio dużej ilości elementów logicznych, dlatego do projektu wybrano układ \textit{Virtex 7} znajdujący się na płytce ewaluacyjnej \textit{VC707}~\cite{VC707_UG}, który został później zastąpiony przez układ \textit{Kintex UltraScale+} wchodzący w skład płytki ewaluacyjnej \textit{KCU116}~\cite{KCU116_UG}. 
\addimage{chapters/ch3/img/vc707.jpg}{scale=0.75}{Płytka ewaluacyjna VC707. Oprócz układu FPGA znajdującego się pod widocznym na zdjęciu układem chłodzenia, płytka ewaluacyjna udostępnia do wykorzystania wiele interfejsów danych i sposobów komunikacji, które mogą zostać użyte przez projektanta w realnym systemie przetwarzania danych~\cite{VC707_UG}}{Płytka ewaluacyjna VC707}{ch3:img:vc707}
Użycie płytek ewaluacyjnych ma tę zaletę, iż wraz z nimi użytkownik otrzymuje dostęp do funkcjonalności oferowanych przez dodatkowe elementy elektroniczne zamontowane na takich płytkach i mogące kooperować z układem FPGA w procesie przetwarzania danych. W kontekście omawianego projektu kluczowe okazały się być możliwość przechowywania danych w pamięci RAM oraz wykorzystanie komunikacji wizualnej zgodnej ze standardem HDMI~(obie wymienione płytki posiadają porty HDMI mogące służyć jako wyjście obrazu).
\begin{savenotes}
\begin{table}[H]
\centering
\caption{Porównanie podstawowych parametrów opisujących wykorzystane układy FPGA}
\label{ch3:tab:fpga_comp}
\begin{tabular}{|r|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{} & \multicolumn{4}{c|}{\textbf{Elementy składowe}} & \multirow{2}{*}{\textbf{Proces technologiczny}} & \multirow{2}{*}{\textbf{Koszt}} \\ \cline{2-5}
                  & BRAM\footnote{Każdy element pamięci blokowej BRAM jest w stanie przechowywać 18~kb danych. W układach FPGA z serii UltraScale oraz UltraScale+ występuje również dodatkowy typ pamięci zwany \textit{UltraRAM}, URAM co w zamierzeniu pozwala przechowywać większe ilości danych bezpośrednio w układzie FPGA~(każdy blok URAM może pomieścić 288 kb danych), zmniejszając konieczność odwoływania się do zewnętrznych zasobów a przez to zwiększając wydajność przetwarzania. }      & DSP\footnote{Moduły DSP znajdują zastosowanie w przypadku akceleracji działań arytmetycznych, zwłaszcza stałopozycyjnych~\cite{DSP48E1}\cite{DSP48E2}. Pozwalają na efektywniejszą implementację i uzyskiwanie wyższych częstotliwości pracy, niż gdyby te same operacje miały zostać wykonane za pomocą LUT.}       & FF         & LUT        &                                                 &                                 \\ \hline
\textbf{VC707}    & 2060      & 2800      & 607200     & 303600     & 28 nm                                           & 3495 \$                         \\ \hline
\textbf{KCU116}   & 960       & 1824      & 433920     & 216960     & 16 nm                                           & 2995 \$                         \\ \hline
\end{tabular}
\end{table}
\end{savenotes}
Oba układy\footnote{Od tej pory, dla wygody, poprzez układ rozumieć należy tak płytkę ewaluacyjną jak i rodzaj układu FPGA, który na niej się znajduje. Związane jest to z faktem, iż pełne nazwy układów FPGA mają skomplikowaną postać zależną od m.in. rodziny, technologii, wielkości czy oceny szybkości~(ang. \textit{speed grade}) układu.} przedstawione w tabeli~\ref{ch3:tab:fpga_comp} posiadają stosunkowo dużą ilość podstawowych elementów, na bazie których można tworzyć funkcjonalność, jednak to VC707 jest znacznie większy pod względem dostępnych zasobów~(różnice zaczynają się od 40\% dla LUT i kończą na 115\% dla pamięci BRAM). Dziwić może zatem zmiana na układ o teoretycznie mniejszych możliwościach. Rzeczywiście KCU116 jest tylko teoretycznie gorszy - jego przewaga uwidoczniła się na etapie implementacji funkcjonalności, dzięki temu, iż jest to układ wykonany w znacznie nowszej technologii, dającej większe możliwości podczas procesu implementacji i łączenia ze sobą elementów za pomocą sieci konfigurowalnych połączeń.
\item U samych podstaw przetwarzania grafiki metodą śledzenia promieni leży fakt, iż obliczenia dotyczące jednej rodziny promieni~(na którą składają się wszystkie promienie powiązane z danym promieniem pierwotnym: odbite, załamane, promienie cieni) odpowiedzialnej za obliczenie koloru konkretnego piksela obrazu są niezależne od pozostałych rodzin. Wynika z tego, że w idealnym przypadku kolory wszystkich pikseli mogłyby być obliczane jednocześnie przez dedykowane dla każdego z nich układy przetwarzające. Realizacja takiego systemu w rzeczywistym układzie FPGA graniczy aktualnie z niemożliwością, choćby ze względu na wymagane w tym celu zasoby sprzętowe. Niemniej jednak udostępniane przez układy FPGA naturalne możliwości przetwarzania jednoczesnego dają duże szanse na zwiększenie efektywności algorytmu, względem jego wersji działającej na procesorze CPU komputera.
\item Jedną z podstawowych cech śledzenia promieni, o której wspomniano przy okazji porównania z rasteryzacją, jest fakt, iż jeśli tylko istnieje sposób matematycznego rozwiązania przecięcia powierzchni z promieniem, to można jej użyć w procesie renderowania bez konieczności stosowania triangulacji. Podczas gdy sfera opisana przez macierz jej przekształcenia jest jednym obiektem, który należy sprawdzić na drodze promienia, triangulacja kuli wymaga setek pojedynczych trójkątów, z którymi taki test trzeba przeprowadzić. Z jednej strony zaproponowane postępowanie niweluje potrzebę stosowania struktur akcelerujących, z drugiej zapewnia, iż uzyskiwane punkty przecięcia będą możliwie dokładne~(w zależności od precyzji obliczeń użytego typu danych).
\item Omawiana technika umożliwia uzyskiwanie realistycznych i interesujących obrazów dopiero wtedy, jeśli zostaną odpowiednio zastosowane różne techniki oświetlenia powierzchni. Tworzony system powinien oferować możliwość użycia różnych funkcji BSDF, które mogłyby być odpowiednio konfigurowane za pomocą parametrów.
\item Nie istnieje ścisła definicja działania programu w czasie rzeczywistym. W branży elektronicznej rozrywki~(tj. gry wideo) przyjmuje się, że minimalna częstotliwość generowania pełnych klatek obrazu, dla zachowania złudzenia płynności, nie powinna być niższa niż 25-30~(chociaż coraz częściej mówi się o 60). Możliwości szybkiego generowania obrazu używając śledzenia promieni zależą głównie od:
\begin{itemize}
\item rozdzielczości klatki obrazu,
\item ilości rozpatrywanych promieni w danej rodzinie,
\item ilości świateł i obiektów w scenie,
\item stosowanych funkcji BSDF.
\end{itemize} 
W związku z tym zachowawczo przyjęto, że jeśli tylko zaprogramowany układ będzie w stanie generować obrazy o rozdzielczości 1280 x 720 pikseli z uwzględnieniem pierwszej rodziny promieni wtórnych w czasie poniżej 0.1s, to efekt taki będzie można uznać za satysfakcjonujący. W sprawdzeniu warunku dostatecznej płynności~(poza standardowym pomiarem czasu wykonania) w praktyce miało pomóc użycie dostępnego na wykorzystywanych płytkach kodeka i portu HDMI\footnote{Poza tym w taki sposób najłatwiej zaprezentować możliwości stworzonego systemu podczas pokazów. Zamiast operować zbiorem statycznych scen, które wcale nie muszą być efektem działającego systemu w układzie FPGA, widz otrzymuje interaktywną~(np. poprzez zmianę położenia obserwatora z pomocą dostępnych na płytce przycisków dowolnego przeznaczenia) demonstrację, w którą jest w stanie uwierzyć.}.
\end{enumerate}

\section{Budowa systemu śledzenia promieni}
Tak postawiony problem można zasadniczo rozwiązać na dwa skrajnie różne sposoby wiążące się z zupełnie innymi wyzwaniami na etapie implementacji:
\begin{enumerate}
\item Stworzenie prostego układu procesorowego, pozwalającego przetwarzać podaną przez użytkownika listę rozkazów implementujących wymagany algorytm.
\item Zaprojektowanie modułu, który implementuje skończony zbiór zachowań~(algorytmów), których wywołanie może być sterowane poprzez parametry wejściowe, czyli tzw. \textit{potok przetwarzania o ustalonej funkcjonalności}~(ang. \textit{fixed pipeline}).
\end{enumerate}
O ile w pierwszym przypadku nadrzędnym celem jest to, aby instrukcje były wykonywane jak najszybciej, a sam układ potrzebował jak najmniej zasobów, o tyle w drugim przypadku może okazać się wyzwaniem pogodzenie ze sobą ilości oferowanych funkcji z dostępnym na układzie miejscem i koniecznością zapewnienia synchronizacji danych na etapie implementacji.

W obu przypadkach ważna jest kontrola nad utylizacją zasobów, która jest nierozerwalnie powiązana z wykorzystywanymi typami danych do przeprowadzenia obliczeń. W tabeli~\ref{ch3:tab:type_area_time} zestawiono jak dużo zasobów potrzeba do implementacji operacji dodawania, mnożenia, dzielenia i pierwiastkowania w przypadku posługiwania się różnymi typami danych oraz ile cykli zegara~(\#) należy oczekiwać na wynik w każdym przypadku. Widać, że w przypadku typów całkowitoliczbowych oraz stałopozycyjnych~(\texttt{ap\_fixed<W, N>}, gdzie \texttt{W} to ilość bitów przypadająca na pełen zapis liczby~(tzw. \textit{długość słowa}), \texttt{N} - bity części całkowitej ze znakiem, a pozostałe przypadają na zapis części ułamkowej) elementarne operacje tj. dodawanie i mnożenie mogą nie tylko być wykonywane w każdym cyklu zegara (\# = 1), ale również zajmują niewiele zasobów układu. Mniejszy z zaprezentowanych typów stałopozycyjnych \texttt{ap\_fixed\textless{}24, 18\textgreater{}} w celu wykonania mnożenia używa 1 zamiast 3 DSP, co może mieć znaczenie w przypadku układów o niwielkiej ilości tychże. Z drugiej strony typy całkowitoliczbowe oraz stałopozycyjne w przypadku dwóch innych działań~(a mających duże znaczenie w momencie rozwiązywania równań kwadratowych oraz normalizacji wektorów) mają albo bardzo duże opóźnienie~(dzielenie), albo wymagają dużej ilości LUT~(pierwiastkowanie). Chcąc dokonać implementacji pierwiastkowania liczby opisanej przez typ \texttt{ap\_fixed\textless{}32, 20\textgreater{}} w układzie VC707 należy liczyć się z koniecznością poświęcenia ok. 1,5\% wszystkich dostępnych LUT. Atrakcyjniej pod tym względem wyglądają typy zmiennoprzecinkowe, a zwłaszcza typy \texttt{half} oraz \texttt{float}. Dziwi jednak fakt, że pierwiastkowanie typu \texttt{half} wymaga znacznie więcej zasobów niż \texttt{float}, jednocześnie przechowując informację tylko o 16 bitach zamiast 32\footnote{Przykład ten ilustruje poziom zaawansowania obsługi typu \texttt{half} przez Vivado HLS.}. Tam gdzie typy całkowitoliczbowe oraz stałopozycyjne pokazywały swoją znaczną przewagę~(tj. dodawanie i mnożenie), tam liczby zmiennoprzecinkowe wymagają więcej zasobów a oczekiwanie na wynik jest dłuższy.  

Wybór reprezentacji danych jest ważnym etapem tworzenia rzeczywistego systemu przetwarzania. Należy odpowiedzieć sobie na pytanie, jakie dane będą przetwarzane oraz jakie będzie ich zróżnicowanie~(dynamika). Jeśli wykorzystywany jest 16 bitowy typ całkowitoliczbowy czy może dojść do sytuacji, że parametry iloczynu mogą dać wynik, który jest większy niż maksymalnie obsługiwany? Czy 8 bitów przeznaczonych na część ułamkową w zapisie stałopozycyjnym umożliwi poprawne znalezienie punktu przecięcia w każdej sytuacji, a jeśli nie to czy zwiększenie szerokości bitowej nie wpłynie negatywnie na inne metryki związane z tworzonym modułem IP? Jakie korzyści może przynieść zastosowanie reprezentacji zmiennoprzecinkowej, jeśli zadaniem układu jest głównie dokonywanie równolegle wielu operacji dodawania i mnożenia?  Podjęcie decyzji i odpowiedzialność za nią spoczywa na projektancie.

\begin{landscape}
\phantom{\rule{1em}{6em}}
\begin{table}[H]
\centering
\caption[Zestawienie typów danych wraz z estymacją wykorzystania poszczególnych zasobów oraz czasu wykonania dla podstawowych operacji arytmetycznych]{Zestawienie danych wraz z estymacją wykorzystania poszczególnych typów zasobów oraz czasu wykonania~(\#) dla podstawowych operacji arytmetycznych. W przypadku pierwiastkowania wartości typu \texttt{half} utylizacja LUT oraz FF musiała zostać oszacowana ze względu na fakt, iż Vivado HLS włącza operacje implementujące to działanie bezpośrednio do hierarchii funkcji, w której zostało wywołane. Do sporządzenia niniejszego zestawienia użyto Vivado HLS 2017.4 dla układu VC707 działającego z częstotliwością 100~MHz}
\label{ch3:tab:op_type_util_time}
\begin{tabular}{|r|l|l|l|l||l|l|l|l||l|l|l|l||l|l|l|l|}
\hline
\multicolumn{1}{|l|}{\multirow{2}{*}{}}           & \multicolumn{4}{c||}{\textbf{Dodawanie}}                                                                       & \multicolumn{4}{c||}{\textbf{Mnożenie}}                                                                       & \multicolumn{4}{c||}{\textbf{Dzielenie}}                                                                      & \multicolumn{4}{c|}{\textbf{Pierwiastek}}                                                                    \\ \cline{2-17} 
\multicolumn{1}{|l|}{}                            & \multicolumn{1}{c|}{LUT} & \multicolumn{1}{c|}{DSP} & \multicolumn{1}{c|}{FF} & \multicolumn{1}{c||}{\#} & \multicolumn{1}{c|}{LUT} & \multicolumn{1}{c|}{DSP} & \multicolumn{1}{c|}{FF} & \multicolumn{1}{c||}{\#} & \multicolumn{1}{c|}{LUT} & \multicolumn{1}{c|}{DSP} & \multicolumn{1}{c|}{FF} & \multicolumn{1}{c||}{\#} & \multicolumn{1}{c|}{LUT} & \multicolumn{1}{c|}{DSP} & \multicolumn{1}{c|}{FF} & \multicolumn{1}{c|}{\#} \\ \hline
\texttt{int}                                      & 39                       & 0                        & 0                       & 1                             & 21                       & 3                        & 0                       & 1                            & 238                      & 0                        & 394                     & 36                           & 1416                     & 0                        & 317                     & 5                            \\ \hline
\texttt{ap\_fixed\textless{}32, 20\textgreater{}} & 39                       & 0                        & 0                       & 1                             & 21                       & 3                        & 0                       & 1                            & 326                      & 0                        & 539                     & 48                           & 4720                     & 0                        & 1281                    & 8                            \\ \hline
\texttt{ap\_fixed\textless{}24, 18\textgreater{}} & 24                       & 0                        & 0                       & 1                             & 40                       & 1                        & 0                       & 1                            & 224                      & 0                        & 370                     & 34                           & 2414                     & 0                        & 433                     & 7                            \\ \hline
\texttt{half}                                     & 112                      & 2                        & 106                     & 4                             & 34                       & 2                        & 64                      & 3                            & 209                      & 0                        & 123                     & 5                            & $\sim$950                & 3                        & $\sim$180               & 6                            \\ \hline
\texttt{float}                                    & 214                      & 2                        & 227                     & 4                             & 135                      & 3                        & 128                     & 2                            & 802                      & 0                        & 359                     & 8                            & 508                      & 0                        & 238                     & 7                            \\ \hline
\texttt{double}                                   & 762                      & 3                        & 430                     & 4                             & 203                      & 11                       & 299                     & 5                            & 3253                     & 0                        & 1697                    & 17                           & 1912                     & 0                        & 1099                    & 17                           \\ \hline
\end{tabular}
\label{ch3:tab:type_area_time}
\end{table}

\end{landscape}

\subsection{Układ procesorowy}
Działanie najprostszego procesora polega na kolejnym:
\begin{enumerate}
\item Pobraniu instrukcji z listy i jej odkodowaniu.
\item Wykonaniu operacji zgodnie z przekazanym opisem.
\item Zapisaniu wyniku.
\item Powrotu do kroku 1. ze zmienionym wskaźnikiem kolejnej instrukcji.
\end{enumerate}
Dostępny dla użytkownika zbiór dozwolonych instrukcji zależy od twórcy danego procesora i określa on swobodę dotyczącą jego programowania. Dla przykładu, w przypadku, gdy nie istnieje sprzętowa obsługa operacji pierwiastkowania, można dokonać emulacji tej funkcjonalności poprzez odpowiednią sekwencję operacji elementarnych~\cite{FAST_INV_SQRT}. Przeważnie czas wykonania emulowanej funkcji będzie dłuższy niż gdyby procesor udostępniał dedykowaną do tego instrukcję. Z punktu widzenia wydajności ważne jest też, aby procesor był zdolny przetwarzać instrukcje z interwałem równym 1 - wykorzystywana jest tutaj niezależność między poszczególnymi etapami przetwarzania instrukcji - z  możliwie najwyższą częstotliwością pracy. 

Jednym z kierunków rozwoju architektur procesorów jest poszukiwanie takiego rozwiązania, które udostępniałoby rozsądny zestaw instrukcji\footnote{Przez to sformułowanie należy rozumieć zachowanie balansu między możliwościami oddawanymi w ręce użytkownika a skomplikowaniem technologicznym.}, jednocześnie wymagając do jego implementacji jak najmniej zasobów sprzętowych. Warto w tym miejscu wspomnieć o projekcie \textit{iDEA}~\cite{iDEA}, który został stworzony od podstaw z myślą o maksymalnym wykorzystaniu znajdujących się w układach FPGA firmy Xilinx bloków DSP. Autorzy zauważyli, że elastyczność oferowana przez bloki DSP pozwala na implementację większości operacji bezpośrednio z ich użyciem. W efekcie uzyskano 32-bitowy procesor\footnote{Wszystkie dostępne instrukcje, za wyjątkiem mnożenia, przeprowadzane są na 32-bitowych liczbach całkowitych. Jedynie parametry mnożenia są ograniczone do 16 bitów~(wynik jest 32-bitowy), z uwagi na fakt, iż bloki DSP, w zależności od wersji, posiadają wbudowany blok dokonujący iloczynu czynników 25(27)- i 18-bitowego.} mogący pracować z częstotliwością ok.~400~MHz przy tym wymagający do jego implementacji jedynie 1~bloku~DSP, 2~BRAM oraz 335~LUT\footnote{Podane wartości dotyczą układu Virtex-6.}. Porównanie tych wartości z oferowanymi przez obecne układy FPGA zasobami~(tabela~\ref{ch3:tab:fpga_comp})  prowadzi do wniosku, że procesorów takiego lub bardziej rozbudowanego typu na jednym układzie można byłoby umieścić setki - otrzymując tym samym sieć procesorów zdolnych współbieżnie i stosunkowo szybko, jak na układy FPGA, przetwarzać dane. 

Na bazie tej obserwacji do tej pory powstało wiele prototypowych systemów, których celem była realizacja śledzenia promieni w czasie rzeczywistym scen o dowolnej złożoności. Wartym wspomnienia jest tutaj cykl prac~\cite{Realtime_FPGA}\cite{RPU}\cite{Realtime_ASIC}, gdzie autorzy szczegółowo przedstawiają, w jaki sposób udało im się osiągnąć zamierzony efekt poprzez bardzo dokładną analizę zależności między podsystemami: pamięci, procesorów oraz jednostek analizujących przecięcia promieni z geometrią i wykorzystanych przez nie zasobów układu FPGA. Udostępniając użytkownikowi możliwość generowania promieni wtórnych do 4 pokolenia, programowanie sposobu oświetlenia powierzchni~(użytkownik mógł tworzyć własne BRDF) oraz przetwarzanie scen złożonych z milionów trójkątów rozwiązanie to potrafiło generować obraz z szybkością co najmniej 1 klatki obrazu na sekundę~(uwarunkowane jest to oczywiście poprzez rozdzielczość obrazu oraz złożoność sceny). Inne ciekawe rozwiązanie zostało zaproponowane w pracy~\cite{TRAX}. Jak podnoszą sami autorzy ich system był prostszy w budowie niż ten, o którym wspomniano wcześniej, jednak eksplorował w znacznie większym stopniu wykorzystanie hierarchicznej sieci prostych procesorów arytmetycznych. Pojedynczy rdzeń~(tych w układzie można było umieszczać dowolne ilości) składał się z 32 wątków zdolnych wykonywać podstawowe operacje na liczbach całkowitych oraz zmiennopozycyjnych jednak w obrębie rdzenia współdzieliły one między siebie jednostki odpowiedzialne za obliczanie iloczynów czy odwrotności liczby. Takie postępowanie było uzasadnione obserwacją, iż w kodzie programu operacje te są wykonywane odpowiednio rzadko i nie ma potrzeby, by każdy z wątków posiadał własne jednostki do przeprowadzania operacji arytmetycznych tego typu.

Cechą wspólną obu przedstawionych systemów śledzenia promieni jest to, że polegają one w znacznym stopniu na wydajności pojedynczego podsystemu przetwarzania instrukcji, który na dodatek musi być odpowiednio niewielki~(używać niewiele zasobów FPGA) aby można było współbieżnie przetwarzać wiele promieni. Co więcej ich twórcy podkreślają rolę języków opisu sprzętu w swobodnym kreowaniu sposobu przepływu danych w ich systemach.

\subsubsection{Projekt układu procesorowego z użyciem Vivado HLS}
Niniejszy projekt układu procesorowego wykonano dla układu VC707 przy użyciu Vivado Design Suite 2017.2 {\color{red} i jego kod można pobrać z ...}. Stworzony moduł IP zaprojektowano w taki sposób, aby jego uruchomienie z dostarczoną listą instrukcji skutkowało zapisem danych do bufora klatki obrazu o podanych rozmiarach, stąd dla każdego piksela w pętli z zastosowaną dyrektywą \texttt{DATAFLOW}\footnote{\color{red}NOTKA ODNOŚNIE (NIE)DZIAŁANIA DATAFLOW W 2017.2} najpierw następuje wygenerowanie promienia o odpowiednim punkcie początkowym i kierunku~(\texttt{CreateRay()}), potem następuje przetworzenie instrukcji (\texttt{ProcessInstructions()}), zwieńczone zapisem wartości do bufora koloru w odpowiednim miejscu~(\texttt{PutColor()}). Dalszy opis będzie skoncentrowany tylko na zagadnieniach związanych z przetwarzaniem rozkazów przez \texttt{ProcessInstructions()}.
\paragraph{Rejestry procesora i architektura instrukcji}
Z uwagi na fakt, iż śledzenie promieni wymaga przetwarzania danych wektorowych podjęta została decyzja o tym by procesor miał do swojej dyspozycji 16 rejestrów wewnętrznych [0, 15], z których każdy składa się z 4 32-bitowych elementów, co pozwoliłoby na przechowywanie większości potrzebnych danych. Każda instrukcja natomiast składa się z 4 wykonywanych jednocześnie podinstrukcji, których wynikiem w przypadku działań arytmetycznych jest skalar, którego wartość może być zapisana  do dowolnego rejestru wektorowego, jednakże indeks zapisu w rejestrze wektorowym jest jednakowy z indeksem podinstrukcji~{\color{red}OGRANICZENIE}. Każda podinstrukcja jest opisana za pomocą 32-bitowej wartości, której rozmieszczenie i znaczenie poszczególnych bitów, w zależności od typu podinstrukcji, zostało ukazane na poniższym rysunku:
\addimage{chapters/ch3/img/instruction.png}{scale=0.43}{Rozmieszczenie bitów danych opisujących podinstrukcję}{Rozmieszczenie bitów danych opisujących podinstrukcję}{ch3:img:instruction}
\begin{itemize}
\item[] [31:28] - \texttt{it} - opisuje rodzaj podinstrukcji, która ma być wykonana,
\item[] [27:23] - \texttt{wr} - indeks rejestru wektorowego, do którego zostanie zapisany rezultat~(indeks skalara w wektorze jest dedukowany na podstawie numeru podinstrukcji),
\item[] [22:21] - \texttt{idx0} - indeks skalara pierwszego parametru~(inne znaczenie w przypadku skoku warunkowego, patrz tabela~\ref{ch3:tab:instructions}),
\item[] [20:29] - \texttt{idx1} - indeks skalara drugiego parametru~(inne znaczenie w przypadku skoku warunkowego, patrz tabela~\ref{ch3:tab:instructions}),
\item[] [15:8] - \texttt{r0} - wartość liczbowa ze znakiem, wskazująca na indeks rejestru wektorowego będącego pierwszym parametrem, jeśli wartość jest ujemna tzn. [15] == 1 wartość tego rejestru wzięta do obliczeń zostanie zanegowana,
\item[] [7:0] - \texttt{r1} - wartość liczbowa ze znakiem, wskazująca na indeks rejestru wektorowego będącego drugim parametrem, jeśli wartość jest ujemna tzn. [7] == 1 wartość tego rejestru wzięta do obliczeń zostanie zanegowana,
\item[] [19:0] - \texttt{val} - stała podawana przez użytkownika
\end{itemize}
Stworzony procesor potrafi przetwarzać 16 instrukcji zebranych i opisanych w tabeli~\ref{ch3:tab:instructions}. Chociaż przedstawiony zbiór instrukcji jest niewielki, procesor jest w stanie dokonywać obliczeń przecięcia promieni z obiektami oraz dokonywać obliczeń koloru danego piksela~(zwłaszcza po uwzględnieniu obecności instrukcji \textbf{PRE\_S} oraz \textbf{PRE\_D}, które dokonują inicjalizujących manipulacji na parametrach będących wstępem do obliczeń metodą Newtona-Raphsona). 
\input{chapters/ch3/instructions}
\paragraph{Działanie procesora} Schemat przetwarzania został ukazany na rysunku~\ref{ch3:img:processing_pipeline}. 
\addimage{chapters/ch3/img/processing_pipeline.png}{scale=0.4}{Potok przetwarzania w stworzonym procesorze. Wejście stanowi lista instrukcji oraz dane zewnętrzne. W pętli zoptymalizowanej dyrektywą \texttt{PIPELINE} następuje pobranie instrukcji, jej odkodowanie a następnie przetworzenie przez układy logiczne i/lub arytmetyczny~(ALU). Wyniki są zapisywane do odpowiednich rejestrów i przetwarzana jest kolejna instrukcja. Po wykonaniu wszystkich instrukcji pierwszy z rejestrów wektorowych jest przyjmowany za ten, którego zawartość stanowi kolor piksela}{Potok przetwarzania w stworzonym procesorze}{ch3:img:processing_pipeline}
Widać na nim (oraz co wynika z analizy dostępnych instrukcji), że jest to układ nieskomplikowany, pozbawiony pamięci podręcznej czy możliwości zwrotnego asynchronicznego zapisu wartości poza układ za to z licznymi ograniczeniami~(opisanymi w uwagach w tabeli~\ref{ch3:tab:instructions}). Rzecz w tym, że Vivado HLS nie umożliwiło jego dalszej komplikacji i to przez co najmniej kilka przyczyn. 
\begin{enumerate}
\item Z uwagi na występujące w procesorach sprzężenie zwrotne między rejestrami, Vivado HLS dobiera taki interwał pomiędzy przetwarzaniem kolejnych instrukcji, aby w każdym przypadku zapis wyniku do rejestru następował przed jego możliwym odczytem związanym z przetwarzaniem kolejnej instrukcji. Teoretycznie zachowanie się Vivado HLS w przypadku wykrycia przez nie zależności między danymi można modyfikować dzięki zastosowaniu dyrektywy \texttt{DEPENDENCE}, jednak w żaden sposób nie udało się tego wymusić, a czas syntezy HLS znacznie wzrastał (z kilku minut do kilku godzin). Gdyby ta optymalizacja działała, można byłoby z teoretycznymi zależnościami między instrukcjami radzić sobie poprzez odpowiednie napisanie kodu (zmieniając kolejność instrukcji bez wpływu na algorytm czy wstawianie instrukcji pustych \texttt{NOP}). 

Poleganie jedynie na statycznym osądzie HLS co do zależności między danymi wymusiło, aby operacje wykonywane przez jednostkę arytmetyczną~(ALU) były wykonywane jak najszybciej. Zgodnie z informacjami zawartymi w tabeli~\ref{ch3:tab:op_type_util_time} nadawały się do tego jedynie typy liczbowe stałopozycyjne, dla których czas wykonania operacji dodawania i mnożenia zawiera się w jednym cyklu zegara. Przyjęto zatem, że elementy skalarne rejestrów wektorowych będą typu \texttt{ap\_fixed<32, 16>}, zaś wartości, które są wczytywane bezpośrednio z przekazanej podinstrukcji~(\texttt{val}) \texttt{ap\_fixed<19, 13>}. Mimo takich zabiegów Vivado HLS mógł jedynie zaoferować interwał równy 3~(opóźnienie iteracji pętli wyniosło 12) przy częstotliwości zegara~100~MHz. 

\item Z podobnych przyczyn jak powyżej nie udało się dokonać implementacji skoków między partiami wykonywanego programu (skoki są ważne wszędzie tam, gdzie dochodzi do warunkowego wykonania jakiejś porcji instrukcji). W większości procesorów, gdy następuje konieczność wykonania skoku następuje wyczyszczenie potoku przetwarzania~(tzn. wszystkie instrukcje, które rozpoczęły być przetwarzane zanim znaleziono polecenie skoku są dyskredytowane, a wskaźnik na kolejną instrukcję jest ustalony w nowym miejscu). W prezentowanym rozwiązaniu teoretycznie istnieją polecenia dokonujące skoku \texttt{JMP}, \texttt{JMP\_IF}, \texttt{JMP\_IFN} jednak ich efektem działania jest tylko to, że wyniki przetwarzanych \texttt{unsigned(val)} instrukcji nie są zapisywane~(nie można też przez to cofać się w wykonaniu instrukcji, co uniemożliwia tworzenie pętli). W rezultacie każda dodana instrukcja, na którą składają się 4 podinstrukcje, dodaje stały przyczynek do czasu wykonania równy interwałowi~(3 cykle zegara). 

\item Implementacja powyższego procesora w strukturze układu VC707 wymaga stosunkowo dużej ilości zasobów~(tabela~\ref{ch3:tab:spu_util}). 

\begin{table}[H]
\centering
\caption{Wykorzystanie zasobów sprzętowych przez procesor instrukcji~(\texttt{ProcessInstructions()}) raportowane po syntezie HLS}
\label{ch3:tab:spu_util}
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{BRAM}} & \multicolumn{1}{c|}{\textbf{DSP}} & \multicolumn{1}{c|}{\textbf{FF}} & \multicolumn{1}{c|}{\textbf{LUT}} \\ \hline
0                                   & 64                                & 41457                            & 17404                             \\ \hline\hline
0\%                                 & 2,29\%                            & 6,83\%                           & 5,73\%                            \\ \hline
\end{tabular}
\end{table}

W dużej mierze wynika to z przyjętego przetwarzania 4 podinstrukcji jednocześnie, gdzie każda z nich może odwoływać się do dwóch dowolnych rejestrów wektorowych. Układy BRAM, które implementują funkcjonalność tablic umożliwiają do dwóch operacji dostępu w jednym cyklu zegara. Mogłoby się wydawać, że w takim razie pamięć związaną z rejestrami można podzielić na 4 i wtedy każda podinstrukcja będzie wykorzystywała dostępne dla siebie 2 operacje odczytu. Nie jest to prawdą, gdyż nieznany jest schemat dostępu do danych~(instrukcje wymagane przez użytkownika mogą odwoływać się dowolnie do rejestrów) stąd konieczność użycia kompletnego podziału tablicy (dyrektywa \texttt{ARRAY\_PARTITION}) rejestrów na poszczególne składowe - okupione jest to znacznym wzrostem zapotrzebowania na LUT i FF. Pozornym rozwiązaniem tego problemu, byłoby przejście na tradycyjny model przetwarzania tylko jednego rozkazu przez jedną instrukcję. Takie działanie wydłużyłoby tylko listę rozkazów lecz powyższe 2 problemy by pozostały.

\end{enumerate}

\addimage{chapters/ch3/img/depth_map_sphere.png}{scale=0.5}{•}{short}{ch3:img:depth_map_sphere}
\addimage{chapters/ch3/img/depth_map_sphere_cut.png}{scale=0.5}{•}{short}{ch3:img:depth_map_sphere_cut}














\section{Dwa podejścia do tworzenia akceleratora}
\subsection{Sieć wyspecjalizowanych softprocessorów}
RISC, własne iteracje - do czego doszliśmy, prezentacja ISA, wydajność, czemu jest źle (DEPENDENCY oraz AREA)
\subsection{Wyspecjalizowany akcelerator o ustalonej funkcjonalności}
\subsubsection{Przepływ danych przez akcelerator}
Zgrubne i bardziej szczegółowe opisanie funkcjonalności poszczególnych bloczków
\subsubsection{Optymalizacje czasu i powierzchni za pomocą dyrektyw}
DATAFLOW, ATAN2, ACOS

\subsection{Ograniczenia}
Brak MC, ograniczona ilość obiektów i świateł, brak obsługi przezroczystości, obrazy LDR, brak swobodnej orientacji (z uwagi na ograniczenia technologiczne)

\section{Implementacja w układzie}
\subsection{Przepływ danych}
\subsubsection{MicroBlaze}
\subsubsection{ADV7511}
Jaki max zegar udało się uzyskać???

\section{Oprogramowanie mikrokontrolera}
Inicjalizacja, obsługa kontrolera animacji, prezentacja przykładowej sceny i wydajności.
\section{WPADKI}
Małe zmiany w kodzie - ogromne w układzie: brak determinizmu i wynikające z tego problemy w poszukiwaniu optymalnych rozwiązań.
\begin{itemize}
\item Użycie Kintexa U+ podyktowane było nowocześniejszą technologią. VC707 posiada więcej elementów logicznych jednak starsza technologia wykonania nie pozwoliła zaimplementować symulacji odbić i cieni pierwszego rzędu. Z drugiej strony płytka z VC707 posiada pełne wyprowadzenie do ADV7511 i nie wymagane były specjalne dodatkowe zabiegi związane z kodowaniem koloru - artefaktów koloru nie było.
\item Nawet najmniejsza zmiana w kodzie może mieć wpływ na spełnienie wymagań czasowych podczas implementacji. Błąd znaleziony w obliczeniach współczynników Fresnela dla materiałów przewodzących, którego załatanie w C sprowadzało się do zmiany miejsca obliczania kwadratów amplitudowych współczynników odbicia w przypadku dielektryków, zmusiło do zmniejszenia zegara układu z 335MHz do 320MHz
\item Pomimo, iż w praktyce korzystniej byłoby dokonanie takiej implementacji, która pomija DATAFLOW i buforowanie wierszy pikseli tzn. użyty byłby potok PIPELINE(specjalny przełącznik w pliku konfiguracyjnym typedefs.h) i piksele zapisywane byłyby w każdej iteracji, bezpośrednio na zewnętrznej pętli renderowania to na etapie implementacji okazało się również, że jest to rozwiązanie nieimplementowalne przynajmniej z takim samym zegarem niż rozwiązanie buforowane przez co nie ma zysku netto czasu wykonania
\item Chociaż model Oren-Nayar oświetlenia powierzchni wydaje się stosunkowo prosty (porównywalny z Torrance-Sparrow) w implementacji w kodzie C sprawia on, że rozwiązanie staje się nieimplementowalne nawet po znacznym obniżeniu taktowania zegara. Użycie zasobów jest większe (w szczególności LUT wzrasta o 2\% dla Kintexa) niż zwykły model Lamberta jednak przeprowadzono zabiegi mające na celu redukcję rozmiaru układu jako całości poprzez zmniejszenie precyzji obliczeń w niekrytycznych miejscach układu (np. w module teksturującym) co przełożyło się na ok. 8\% zmniejszenie zapotrzebowania na LUT. W tym celu wykorzystano typ zmiennoprzecinkowy połówkowej precyzji (half). Implementacja wykazała, że zabieg ten nie wpłynął pozytywnie na implementowalność zatem należy sądzić, że Vivado napotyka trudności w implementacji nie z powodu rozmiaru całego układu a wskutek operacji wykonywanych w celu obliczenia współczynnika rozproszenia w modelu Oren-Nayar (przy obliczeniach ON wykorzystywano w głównej mierze typ połówkowy)

\end{itemize}